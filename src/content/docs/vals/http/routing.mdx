---
title: Routing
description: How to implement routing within HTTP triggers to handle different paths and methods
generated: 1701279907950
sidebar:
  order: 3
---

import Val from "@components/Val.astro";

One of the coolest things about the Request/Response API is that it works with modern web frameworks, so you can use routing and their helper methods! When an
HTTP file is deployed, it is available at a subdomain like
`handle-valname.web.val.run`, and requests to any subdirectory
or path will be routed to the file.

### Hono

We typically recommend [Hono](https://hono.dev/):

<Val
  url="https://www.val.town/embed/x/valdottown/HTTP_examples/Routing/honoExample"
  height="240px"
/>

### Peko

And one with [Peko](https://peko.deno.dev/):

<Val
  url="https://www.val.town/embed/x/valdottown/HTTP_examples/Routing/pekoExample"
  height="300px"
/>

### nhttp

And [nhttp](https://github.com/nhttp/nhttp):

<Val
  url="https://www.val.town/embed/x/valdottown/HTTP_examples/Routing/nhttpExample"
  height="350px"
/>

### itty-router

A super tiny example with [itty-router](https://itty.dev/itty-router):

<Val
  url="https://www.val.town/embed/x/valdottown/HTTP_examples/Routing/ittyExample"
  height="250px"
/>

### feTS

A simple example of using [feTS server](https://the-guild.dev/openapi/fets/server/quick-start):

<Val url="https://www.val.town/embed/x/valdottown/HTTP_examples/Routing/fetsExample" />

Notice, that it exports the `router`, which allows to use the [feTS client](https://the-guild.dev/openapi/fets/client/quick-start) to make routes type safe:

```tsx val
import { type router } from "https://esm.town/v/user/fetsServer";
import { createClient } from "npm:fets";

const client = createClient<typeof router>({
  endpoint: "https://user-fetsServer.web.val.run",
});

// The `response` and `greetings` have proper types automatically inferred
const response = await client["/greetings"].get();
const greetings = await response.json();
console.log(greetings);
```
